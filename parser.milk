operatormap = l => l.map(x => ['operator', x])
leftdelimitermap = l => l.map(x => ['leftdelimiter', x])

assignmentOp = operatormap([
    '=', '+=', '-=', '*=',
    '^=', '/=', '%='
])

comparisonOp = operatormap([
    '<=', '>=', '<', '>', '==',
    '!=', 'equals', 'not equals'
])

elementOp = operatormap([
    'in', 'instanceof', 'not in'
])

additionOp = operatormap(['+', '-'])
multOp = operatormap(['*', '/', '%'])
prepostOp = operatormap(['++', '--'])
unaryOp = operatormap(['typeof', '!'])
dotOp = operatormap(['.', '?.', '()', '?()', '[]', '?[]'])
bracketDel = leftdelimitermap(['[', '?['])

function searchTokenR(*needles, hay):
    for i, token in hay:
        if needles.some(x => token[0...x.length - 1] equals x):
            return i

    return -1

function searchTokenL(*needles, hay):
    if hay.length == 0: return -1

    for i in [hay.length - 1...0]:
        if needles.some(x => hay[i][0...x.length - 1] equals x):
            return i

    return -1

function searchTokens(*needles, hay):
    r = []

    for i, token in hay:
        if needles.some(x => token equals x):
            r.push(i)

    return r

// Expression

function parseExpression(tokens, *exclude):
    output = []
    [parenDepth, bracketDepth, braceDepth] = [0, 0, 0]

    // Detect objects & parentheses
    for i in [0, 1, ..., tokens.length - 1]:
        token = tokens[i]

        if token[0] == 'delimiter'
        || token[0] == 'rightdelimiter'
        || token[0] == 'newline'
        || token equals ['keyword', 'for']
        || exclude.some(x => x equals token):
            // Detect end of expression
            break

        else if token equals ['keyword', 'function']:
            // Function closure
            [tree, end] = parseFunction(tokens[i...])
            return [tree, i + end]

        else if assignmentOp.some(x => x equals token):
            // Drop everything!
            [pattern, _] = parsePattern(tokens[0...i - 1])
            [tree, end] = parseExpression(tokens[i + 1...])

            return [[token[1], pattern, tree], i + 1 + end]

        else if token equals ['leftdelimiter', '(']
        && tokens[i - 1]?[0] in [null, 'operator', 'newline']:
            // Expression grouping
            [tree, end] = parseExpression(tokens[i + 1...])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '(']
        || token equals ['leftdelimiter', '?(']:
            // Function call
            [tree, end] = parseArray(tokens[i + 1...])
            output.push(['operator', token[1] + ')'])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '[']
        || token equals ['leftdelimiter', '?[']:
            // Indexer or array
            indexer = tokens[i - 1]?[0] not in [null, 'operator', 'newline']

            [tree, end] = parseArray(tokens[i + 1...])
            if indexer: output.push(['operator', token[1] + ']'])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '{']:
            // Object
            [tree, end] = parseObject(tokens[i + 1...])
            output.push(tree)
            i += end + 1
            continue

        output.push(token)

    // Group stuff
    if (k = searchTokenR(['operator', '=>'], output)) != -1:
        [left, _] = parseLambdaHead(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['lambda', null, left, right]

    else if (k = searchTokenR(['operator', '?'], output)) != -1:
        m = searchTokenR(['operator', ':'], output)
        if m < k: throw {
            message: "Didn't find the ':' to the '?'",
            offset: output[k].offset
        }

        [condition, _] = parseExpression(output[0...k - 1])
        [left, _] = parseExpression(output[k + 1...m - 1])
        [right, _] = parseExpression(output[m + 1...])

        output = ['?', condition, left, right]

    else if (k = searchTokenR(['operator', '??'], output)) != -1
    || (k = searchTokenL(['operator', '||'], output)) != -1
    || (k = searchTokenL(['operator', '&&'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (kk = searchTokens(*comparisonOp, output)).length > 0:
        r = kk.length > 1 ? ['chaincmp'] : []

        for m, _ in kk:
            start = m >= 1 ? kk[m - 1] + 1 : 0
            [expr, _] = parseExpression(output[start...kk[m] - 1])
            r.push(expr)
            r.push(output[kk[m]][1])

        [expr, _] = parseExpression(output[kk[m] + 1...])
        r.push(expr)

        if kk.length == 1:
            output = [r[1], r[0], r[2]]
        else:
            output = r

    else if (k = searchTokenL(*elementOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (k = searchTokenL(*additionOp, output)) != -1:
        unary = output[k - 1]?[0] in [null, 'operator', 'leftdelimiter', 'delimiter']
        left = null

        if !unary: [left, _] = parseExpression(output[0...k - 1])
        [right, end] = parseExpression(output[k + 1...])

        if unary:
            output[k...k + end] = [[output[k][1], right]]
            [output, _] = parseExpression(output)
        else:
            output = [output[k][1], left, right]

    else if (k = searchTokenL(*multOp, output)) != -1:
        unary = output[k][1] == '*' && output[k - 1]?[0] in [null, 'operator', 'leftdelimiter', 'delimiter']
        left = null

        if !unary: [left, _] = parseExpression(output[0...k - 1])
        [right, end] = parseExpression(output[k + 1...])

        if unary:
            output[k...k + end] = [['spread', right]]
            [output, _] = parseExpression(output)
        else:
            output = [output[k][1], left, right]

    else if (k = searchTokenL(*prepostOp, output)) != -1:
        prevType = output[k - 1]?[0]
        nextType = output[k + 1]?[0]

        l = [null, 'newline', 'operator']
        prefix = prevType in l && nextType not in l
        postfix = nextType in l && prevType not in l

        if prefix == postfix: throw {
            message: "Ambiguous operator '" + output[k][1] + "'"
            offset: output[k].offset
        }

        if prefix:
            [subject, _] = parseExpression(output[k + 1...])
            output = [output[k][1] + '_', subject]
        else:
            [subject, _] = parseExpression(output[0...k - 1])
            output = ['_' + output[k][1], subject]

    else if (k = searchTokenL(*unaryOp, output)) != -1:
        [subject, end] = parseExpression(output[k + 1...])

        output[k...k + end] = [['spread', right]]
        [output, _] = parseExpression(output)

    else if (k = searchTokenR(['operator', '^'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['^', left, right]

    else if (k = searchTokenR(['operator', 'new'], output)) != -1:
        [subject, end] = parseExpression(output[k + 1...])
        output[k...k + end] = [['new', subject]]
        [output, _] = parseExpression(output)

    else if (k = searchTokenL(*dotOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    if output.length == 1: output = output[0]
    return [output, i]

// Pattern matching

function parsePattern(tokens):
    [[type, value], ...] = tokens

    if type == 'leftdelimiter':
        if value == '[':
            [pattern, end] = parseArrayPattern(tokens[1...])
            return [pattern, end + 1]
        else if value == '{':
            [pattern, end] = parseObjectPattern(tokens[1...])
            return [pattern, end + 1]
    else:
        [expr, end] = parseExpression(tokens, ['operator', 'in'])
        type = expr[0]

        if type in ['[]', '?[]', '.', '?.', 'identifier']
        || type equals ['keyword', '_']:
            return [expr, end]

    throw {
        message: "Invalid pattern",
        offset: tokens[0].offset
    }

function parseArrayPattern(tokens):
    output = ['arraypattern']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']
        || token[0] == 'newline':
            pointer++
        else if token equals ['delimiter', '...']:
            if output.some(x => x[0] == 'spread'): throw {
                message: "Invalid multiple spreads in an array pattern",
                offset: token.offset
            }

            output.push(['spread', ['keyword', '_']])
            pointer++
        else if token equals ['operator', '*']:
            [expr, end] = parsePattern(tokens[pointer + 1...])
            output.push(['spread', expr])
            pointer += end + 1
        else:
            [expr, end] = parsePattern(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseObjectPattern(tokens):
    output = ['objpattern']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']
        || token[0] == 'newline':
            pointer++
        else:
            [expr, end] = parseObjectPatternItem(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseObjectPatternItem(tokens):
    output = []
    pointer = 0

    [expr, end] = parseExpression(tokens)
    output.push(expr)
    pointer += end

    if tokens[pointer] equals ['delimiter', ':']:
        pointer++
        [pattern, end] = parsePattern(tokens[pointer...])
        pointer += end
        output.push(pattern)

    if tokens[pointer] equals ['delimiter', ':']:
        throw {
            message: "Unexpected ':'",
            offset: tokens[pointer].offset
        }

    if output.length == 1:
        node = output[0]

        if node[0] != 'identifier': throw {
            message: "Identifier expected",
            offset: tokens[0].offset
        }

        output = [node, node]

    return [output, pointer]

// Objects

function parseFunction(tokens):
    output = ['function']
    pointer = 1

    if tokens[pointer][0] == 'identifier':
        output.push(tokens[pointer])
        pointer++
    else:
        output.push(null)

    try:
        if tokens[pointer] equals ['leftdelimiter', '(']:
            [pattern, end] = parseArrayPattern(tokens[pointer + 1...])
            output.push(pattern)
            pointer += end + 2
        else: throw pointer

        if tokens[pointer] equals ['delimiter', ':']:
            [statements, end] = parseBlock(tokens[pointer + 1...])
            output.push(statements)
            pointer += end + 1
        else: throw pointer

        return [output, pointer]
    catch e:
        throw {
            message: "Unexpected '" + tokens[e][1] + "'",
            offset: tokens[e].offset
        }

function parseArray(tokens):
    output = ['array']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']
        || token[0] == 'newline':
            pointer++
        else if token equals ['keyword', 'for']:
            output[0] = 'arrayfor'

            [forhead, end] = parseForHead(tokens[pointer...])
            output.push(forhead)
            pointer += end
        else if token equals ['delimiter', '...']:
            output.push(token)
            pointer++
        else:
            [expr, end] = parseExpression(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseObject(tokens):
    output = ['object']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']
        || token[0] == 'newline':
            pointer++
        else if token equals ['keyword', 'for']:
            output[0] == 'objectfor'

            [forhead, end] = parseForHead(tokens[pointer...])
            output.push(forhead)
            pointer += end
        else:
            [expr, end] = parseKeyValuePair(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseKeyValuePair(tokens):
    output = []
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter' || token equals ['delimiter', ',']:
            if output.length > 2: throw {
                message: "Object literal has wrong syntax",
                offset: token.offset
            }
            break
        else if token equals ['delimiter', ':']:
            pointer++
        else:
            [expr, end] = parseExpression(tokens[pointer...])
            output.push(expr)
            pointer += end

    if output.length == 1:
        node = output[0]

        if node[0] != 'identifier': throw {
            message: "Identifier expected",
            offset: tokens[0].offset
        }

        output = [node, node]

    return [output, pointer]

// Statements

function parseBlock(tokens):
    if tokens[0] equals ['newline', 'indent']:
        [s, end] = parseStatements(tokens[1...])
        return [s, end + 1]
    else:
        [s, end] = parseStatement(tokens[1...])
        return [['statements', s], end + 1]

function parseStatements(tokens):
    output = ['statements']
    depth = 0
    pointer = 0
    end = tokens.length

    for i in [0, 1, ..., tokens.length - 1]:
        if tokens[i] equals ['newline', 'indent']:
            depth++
        else if tokens[i] equals ['newline', 'dedent']:
            depth--

        if depth < 0:
            end = i
            break

    while pointer <= end:
        [s, e] = parseStatement(tokens[pointer...])
        if s.length != 0: output.push(s)
        pointer += e + 1

    return [output, end]

function parseStatement(tokens):
    return parseExpression(tokens)

// Loops

function parseForHead(tokens):
    pointer = 1
    [first, second, listexpr, condition] = [null, null, null, null]

    [first, len] = parsePattern(tokens[pointer...])
    pointer += len

    if tokens[pointer] equals ['delimiter', ',']:
        pointer++
        [second, len] = parsePattern(tokens[pointer...])
        pointer += len

    if tokens[pointer] equals ['operator', 'in']:
        pointer++
        [listexpr, len] = parseExpression(tokens[pointer...])
        pointer += len
    else: throw {
        message: "Expecting 'in'",
        offset: tokens[pointer].offset
    }

    if tokens[pointer] equals ['keyword', 'if']:
        pointer++
        [condition, len] = parseExpression(tokens[pointer...])
        pointer += len

    return [['for', [first, second], listexpr, condition], pointer]

function parseFor(tokens):
    [forhead, pointer] = parseForHead(tokens)

    if tokens[pointer] not equals ['delimiter', ':']:
        throw {
            message: "Expecting ':'",
            offset: tokens[pointer].offset
        }

    pointer++
    [s, len] = parseBlock(tokens[pointer...])
    forhead.push(s)

    return [forhead, pointer + len]

function parseWhile(tokens):
    [expr, pointer] = parseExpression(tokens[1...])
    pointer++

    if tokens[pointer] not equals ['delimiter', ':']:
        throw {
            message: "Unexpected '" + tokens[pointer][1] + "'",
            offset: tokens[pointer].offset
        }

    pointer++
    [s, len] = parseBlock(tokens[pointer...])

    return [['while', expr, s], pointer + len]

module.exports = parseStatements
