operatormap = l => l.map(x => ['operator', x])
delimitermap = l => l.map(x => ['delimiter', x])

assignmentOp = operatormap([
    '=', '+=', '-=', '*=',
    '^=', '/=', '%='
])

comparisonOp = operatormap([
    '<=', '>=', '<', '>', '==',
    '!=', 'equals', 'not equals'
])

elementOp = operatormap([
    'in', 'instanceof', 'not in'
])

additionOp = operatormap(['+', '-'])
multOp = operatormap(['*', '/', '%'])
prepostOp = operatormap(['++', '--'])
unaryOp = operatormap(['typeof', '!'])
dotOp = delimitermap(['.', '?.'])

function searchTokenR(*needles, hay):
    for i, token in hay:
        if needles.some(x => token equals x):
            return i

    return -1

function searchTokenL(*needles, hay):
    if hay.length == 0: return -1

    for i in [hay.length - 1...0]:
        if needles.some(x => hay[i] equals x):
            return i

    return -1

function searchTokens(*needles, hay):
    r = []

    for i, token in hay:
        if needles.some(x => token equals x):
            r.push(i)

    return r

module.exports = function(tokens):
    return parseExpression(tokens)

function parseExpression(tokens):
    output = []
    depth = 0

    // Detect parentheses
    for i, token in tokens:
        if token equals ['delimiter', '(']:
            if tokens[i - 1]?[0] in [null, 'operator', 'delimiter', 'newline']:
                // Expression grouping
                [tree, i] = parseExpression(tokens[i + 1...])
                output.push(tree)
            else:
                // Function call parentheses
                depth++
                output.push(token)

        else if token equals ['delimiter', ')']:
            if depth > 0:
                depth--
                output.push(token)
            else:
                // End of expression
                break

        else if token equals ['delimiter', ':']
        && tokens?[i + 1] equals ['newline', 'indent']:
            // End of expression
            break

        else if token equals ['delimiter', ',']
        || token equals ['delimiter', ';']
        || token equals ['keyword', 'for']
        || token[0] == 'newline':
            // End of expression
            break

        else:
            output.push(token)

    // Group stuff
    if (k = searchTokenR(*assignmentOp, output)) != -1:
        [left, _] = parsePattern(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['=', left, right]

    else if (k = searchTokenR(['operator', '=>'], output)) != -1:
        [left, _] = parseLambdaHead(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['lambda', null, left, right]

    else if (k = searchTokenR(['operator', '?'], output)) != -1:
        m = searchTokenR(['delimiter', ':'], output)
        [condition, _] = parseExpression(output[0...k - 1])
        [left, _] = parseExpression(output[k + 1...m - 1])
        [right, _] = parseExpression(output[m + 1...])

        output = ['?', condition, left, right]

    else if (k = searchTokenR(['operator', '??'], output)) != -1
    || (k = searchTokenL(['operator', '||'], output)) != -1
    || (k = searchTokenL(['operator', '&&'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (kk = searchTokens(*comparisonOp, output)).length > 0:
        r = kk.length > 1 ? ['chaincmp'] : []

        for m, _ in kk:
            start = m >= 1 ? kk[m - 1] + 1 : 0
            [expr, _] = parseExpression(output[start...kk[m] - 1])
            r.push(expr)
            r.push(output[kk[m]][1])

        [expr, _] = parseExpression(output[kk[m] + 1...])
        r.push(expr)

        if kk.length == 1:
            output = [r[1], r[0], r[2]]
        else:
            output = r

    else if (k = searchTokenL(*elementOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (k = searchTokenL(*additionOp, output)) != -1:
        prevType = output[k - 1]?[0]
        unary = prevType in [null, 'operator']
        left = null

        if !unary: [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        if unary:
            output = [output[k][1], right]
        else:
            output = [output[k][1], left, right]

    else if (k = searchTokenL(*multOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (k = searchTokenL(*prepostOp, output)) != -1:
        prevType = output[k - 1]?[0]
        nextType = output[k + 1]?[0]

        l = [null, 'newline', 'operator']
        prefix = prevType in l && nextType not in l
        postfix = nextType in l && prevType not in l

        if prefix == postfix: throw {
            message: "Ambiguous operator '" + output[k][1] + "'"
            offset: output[k].offset
        }

        if prefix:
            [subject, _] = parseExpression(output[k + 1...])
            output = [output[k][1] + '_', subject]
        else:
            [subject, _] = parseExpression(output[0...k - 1])
            output = ['_' + output[k][1], subject]

    else if (k = searchTokenL(*unaryOp, output)) != -1:
        [subject, _] = parseExpression(output[k + 1...])

        output = [output[k][1], subject]

    else if (k = searchTokenR(['operator', '^'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['^', left, right]

    else if (k = searchTokenR(['operator', 'new'], output)) != -1:
        [subject, _] = parseExpression(output[k + 1...])
        output = ['new', subject]

    else if (k = searchTokenR(*dotOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    if output.length == 1: output = output[0]
    return [output, i]

function parsePattern(tokens):
    return tokens
