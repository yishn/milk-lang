operatormap = l => l.map(x => ['operator', x])
leftdelimitermap = l => l.map(x => ['leftdelimiter', x])

assignmentOp = operatormap([
    '=', '+=', '-=', '*=',
    '^=', '/=', '%='
])

comparisonOp = operatormap([
    '<=', '>=', '<', '>', '==',
    '!=', 'equals', 'not equals'
])

elementOp = operatormap([
    'in', 'instanceof', 'not in'
])

additionOp = operatormap(['+', '-'])
multOp = operatormap(['*', '/', '%'])
prepostOp = operatormap(['++', '--'])
unaryOp = operatormap(['typeof', '!'])
dotOp = operatormap(['.', '?.', '()', '?()', '[]', '?[]'])
bracketDel = leftdelimitermap(['[', '?['])

function searchTokenR(*needles, hay):
    for i, token in hay:
        if needles.some(x => token[0...x.length - 1] equals x):
            return i

    return -1

function searchTokenL(*needles, hay):
    if hay.length == 0: return -1

    for i in [hay.length - 1...0]:
        if needles.some(x => hay[i][0...x.length - 1] equals x):
            return i

    return -1

function searchTokens(*needles, hay):
    r = []

    for i, token in hay:
        if needles.some(x => token equals x):
            r.push(i)

    return r

module.exports = function(tokens):
    return parseExpression(tokens)

function parseExpression(tokens):
    output = []
    [parenDepth, bracketDepth, braceDepth] = [0, 0, 0]

    // Detect parentheses
    for i in [0, 1, ..., tokens.length - 1]:
        token = tokens[i]

        // Detect end of expression
        if token equals ['delimiter', ':']
        && tokens?[i + 1] equals ['newline', 'indent']:
            break

        else if token[0] == 'delimiter'
        || token[0] == 'rightdelimiter'
        || token[0] == 'newline'
        || token equals ['keyword', 'for']:
            break

        else if token equals ['leftdelimiter', '(']
        && tokens[i - 1]?[0] in [null, 'operator', 'newline']:
            // Expression grouping
            [tree, end] = parseExpression(tokens[i + 1...])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '(']
        || token equals ['leftdelimiter', '?(']:
            // Function call
            [tree, end] = parseArray(tokens[i + 1...])
            output.push(['operator', token[1] + ')'])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '[']
        || token equals ['leftdelimiter', '?[']:
            // Indexer or array
            indexer = tokens[i - 1]?[0] not in [null, 'operator', 'newline']

            [tree, end] = parseArray(tokens[i + 1...])
            if indexer: output.push(['operator', token[1] + ']'])
            output.push(tree)

            i += end + 1
            continue

        else if token equals ['leftdelimiter', '{']:
            // Object
            [tree, end] = parseObject(tokens[i + 1...])
            output.push(tree)
            i += end + 1
            continue

        output.push(token)

    // Group stuff
    if (k = searchTokenR(*assignmentOp, output)) != -1:
        [left, _] = parsePattern(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['=', left, right]

    else if (k = searchTokenR(['operator', '=>'], output)) != -1:
        [left, _] = parseLambdaHead(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['lambda', null, left, right]

    else if (k = searchTokenR(['operator', '?'], output)) != -1:
        m = searchTokenR(['delimiter', ':'], output)
        [condition, _] = parseExpression(output[0...k - 1])
        [left, _] = parseExpression(output[k + 1...m - 1])
        [right, _] = parseExpression(output[m + 1...])

        output = ['?', condition, left, right]

    else if (k = searchTokenR(['operator', '??'], output)) != -1
    || (k = searchTokenL(['operator', '||'], output)) != -1
    || (k = searchTokenL(['operator', '&&'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (kk = searchTokens(*comparisonOp, output)).length > 0:
        r = kk.length > 1 ? ['chaincmp'] : []

        for m, _ in kk:
            start = m >= 1 ? kk[m - 1] + 1 : 0
            [expr, _] = parseExpression(output[start...kk[m] - 1])
            r.push(expr)
            r.push(output[kk[m]][1])

        [expr, _] = parseExpression(output[kk[m] + 1...])
        r.push(expr)

        if kk.length == 1:
            output = [r[1], r[0], r[2]]
        else:
            output = r

    else if (k = searchTokenL(*elementOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    else if (k = searchTokenL(*additionOp, output)) != -1:
        unary = output[k - 1]?[0] in [null, 'operator', 'leftdelimiter', 'delimiter']
        left = null

        if !unary: [left, _] = parseExpression(output[0...k - 1])
        [right, end] = parseExpression(output[k + 1...])

        if unary:
            output[k...k + end] = [[output[k][1], right]]
            [output, _] = parseExpression(output)
        else:
            output = [output[k][1], left, right]

    else if (k = searchTokenL(*multOp, output)) != -1:
        unary = output[k][1] == '*' && output[k - 1]?[0] in [null, 'operator', 'leftdelimiter', 'delimiter']
        left = null

        if !unary: [left, _] = parseExpression(output[0...k - 1])
        [right, end] = parseExpression(output[k + 1...])

        if unary:
            output[k...k + end] = [['spread', right]]
            [output, _] = parseExpression(output)
        else:
            output = [output[k][1], left, right]

    else if (k = searchTokenL(*prepostOp, output)) != -1:
        prevType = output[k - 1]?[0]
        nextType = output[k + 1]?[0]

        l = [null, 'newline', 'operator']
        prefix = prevType in l && nextType not in l
        postfix = nextType in l && prevType not in l

        if prefix == postfix: throw {
            message: "Ambiguous operator '" + output[k][1] + "'"
            offset: output[k].offset
        }

        if prefix:
            [subject, _] = parseExpression(output[k + 1...])
            output = [output[k][1] + '_', subject]
        else:
            [subject, _] = parseExpression(output[0...k - 1])
            output = ['_' + output[k][1], subject]

    else if (k = searchTokenL(*unaryOp, output)) != -1:
        [subject, end] = parseExpression(output[k + 1...])

        output[k...k + end] = [['spread', right]]
        [output, _] = parseExpression(output)

    else if (k = searchTokenR(['operator', '^'], output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = ['^', left, right]

    else if (k = searchTokenR(['operator', 'new'], output)) != -1:
        [subject, _] = parseExpression(output[k + 1...])
        output = ['new', subject]

    else if (k = searchTokenL(*dotOp, output)) != -1:
        [left, _] = parseExpression(output[0...k - 1])
        [right, _] = parseExpression(output[k + 1...])

        output = [output[k][1], left, right]

    if output.length == 1: output = output[0]
    return [output, i]

function parsePattern(tokens):
    return parseExpression(tokens)

function parseArray(tokens):
    output = ['array']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']:
            pointer++
        else if token equals ['keyword', 'for']:
            [forhead, end] = parseForHead(tokens[pointer...])
            output.push(forhead)
            pointer += end
        else if token equals ['delimiter', '...']:
            output.push(token)
            pointer++
        else:
            [expr, end] = parseExpression(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseObject(tokens):
    output = ['object']
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter':
            break
        else if token equals ['delimiter', ',']:
            pointer++
        else if token equals ['keyword', 'for']:
            [forhead, end] = parseForHead(tokens[pointer...])
            output.push(forhead)
            pointer += end
        else:
            [expr, end] = parseKeyValuePair(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseKeyValuePair(tokens):
    output = []
    pointer = 0

    while pointer < tokens.length:
        token = tokens[pointer]

        if token[0] == 'rightdelimiter' || token equals ['delimiter', ',']:
            break
        else if token equals ['delimiter', ':']:
            pointer++
        else:
            [expr, end] = parseExpression(tokens[pointer...])
            output.push(expr)
            pointer += end

    return [output, pointer]

function parseForHead(tokens):
    return tokens
