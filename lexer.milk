escaperegex = x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
regexmap = l => l.map(x => new RegExp('^' + escaperegex(x)))

function gcd(*args):
    if args.length <= 1: return args[0] ?? 1

    gcdInner = (a, b) => b == 0 ? a : gcdInner(b, a % b)

    middle = Math.floor((args.length - 1) / 2)
    return gcdInner(gcd(*args[0...middle]), gcd(*args[middle + 1...]))

rules = {
    operator: regexmap([
        '*', '/', '^', '%', '-', '+',
        '=', '--', '++', '+=', '^=', '*=', '%=', '-=', '+=',
        '=>', '??', '?',
        '||', '&&', '!',
        '<', '>', '<=', '>=', '==', '!=',
        'in', 'not in', 'instanceof', 'typeof', 'new',
        'equals', 'not equals'
    ])

    delimiter: regexmap([
        ';', ',', '.', '?.', '(', '?(', ')',
        '[', '?[', ']', '{', '}', ':', '...'
    ])

    newline: [
        /^\n[^\S\n]*/
    ]

    bool: regexmap([
        'true'
        'false'
    ])

    keyword: regexmap([
        '_', 'pass', 'equals',
        'null', 'undefined', 'not', 'true', 'false', 'arguments',
        'export', 'import', 'void', 'debugger', 'with',
        'delete', 'var', 'let', 'const', 'typeof',
        'new', 'class', 'extends', 'this', 'self', 'super',
        'return', 'yield', 'function',
        'if', 'else', 'else if',
        'switch', 'case', 'default',
        'do', 'while', 'break', 'continue',
        'for', 'in', 'of', 'instanceof',
        'try', 'catch', 'finally', 'throw',
        'enum', 'implements', 'static', 'public', 'package',
        'interface', 'protected', 'private', 'abstract', 'final',
        'native', 'boolean', 'float', 'short', 'byte',
        'goto', 'synchronized', 'char', 'int', 'transient', 'double',
        'long', 'volatile'
    ])

    identifier: [
        /^[a-zA-Z_$][0-9a-zA-Z_$]*/
    ]

    sharp: [
        /^#[A-Z]+/
    ]

    number: [
        /^[0-9]+/
        /^[0-9]*\.[0-9]+/
        /^0x[0-9a-fA-F]+/
    ]

    string: [
        /^"("|.*?[^\\]"|.*?\\\\")/
        /^'('|.*?[^\\]'|.*?\\\\')/
    ]

    regex: [
        /^\/(.*?[^\\]\/|.*?\\\\\/)[gim]*/
    ]

    comment: [
        /^\/\/.*/
        /^\/\*[^]*?\*\//
    ]

    ignore: [
        /^[^\S\n]+/
    ]
}

module.exports = function(input):
    [residue, offset] = [input, 0]
    tokens = []

    // Tokenizer
    while residue.length > 0:
        [type, value] = [null, '']

        for t, list in rules:
            for regex in list:
                matches = regex.exec(residue)
                if matches == null || matches[0].length <= value.length:
                    continue

                [type, value] = [t, matches[0]]

        // No token found
        if type == null:
            [row, col] = helper.offsetToLinePos(offset, input)
            throw {
                message: "Syntax error: Unexpected '" + residue[0] + "'"
                offset: offset
            }

        // Don't add newline twice
        if type == 'newline' && tokens.length > 0 && tokens[tokens.length - 1][0] == 'newline':
            tokens.pop()

        if type != 'ignore':
            tokens.push([type, value, offset])

        offset += value.length
        residue = residue[value.length...]

    // Detect indents & dedents
    indents = [x.length - 1 for [t, x, _] in tokens if t == 'newline']
    indentLength = gcd(*indents.filter(x => x != 0))
    [lastDepth, useTabs] = [0, null]

    for i, [type, value, offset] in tokens if type == 'newline':
        depth = (value.length - 1) / indentLength

        if depth != 0:
            // Check for mixed indentation
            if useTabs == null:
                useTabs = '\t' in value
            else if useTabs != ('\t' in value):
                throw {
                    message: 'Mixed indentation',
                    offset: offset
                }

        if depth > lastDepth:
            tokens[i][1] = 'indent'
        else if depth < lastDepth:
            tokens[i][1] = 'dedent'
        else:
            tokens[i][1] = 'nodent'

        lastDepth = depth

    return tokens
