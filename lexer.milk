escaperegex = x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
regexmap = l => l.map(x => new RegExp('^' + escaperegex(x)))

function gcd(*args):
    if args.length <= 1: return args[0] ?? 1

    gcdInner = (a, b) => b == 0 ? a : gcdInner(b, a % b)

    middle = Math.floor((args.length - 1) / 2)
    return gcdInner(gcd(*args[0...middle]), gcd(*args[middle + 1...]))

function removeNewline(tokens, i):
    depth = 0
    for k, token in tokens if k >= i && token != null:
        [type, value] = token

        if type == 'newline':
            if value == 'indent': depth++
            else if value == 'dedent': depth--

            if k == i:
                tokens[k] = null

            if depth == 0:
                tokens[k] = null
                if k != i: return

rules = {
    operator: regexmap([
        '*', '/', '^', '%', '-', '+',
        '=', '--', '++', '+=', '^=', '*=', '%=', '-=', '+=',
        '=>', '??', '?',
        '||', '&&', '!',
        '<', '>', '<=', '>=', '==', '!=',
        'in', 'not in', 'instanceof', 'typeof', 'new',
        'equals', 'not equals',
        '.', '?.'
    ]).concat([/^\s+:\s+/]),

    delimiter: regexmap([
        ';', ',', ':', '...'
    ]),

    leftdelimiter: regexmap([
        '(', '?(', '[', '?[', '{'
    ]),

    rightdelimiter: regexmap([
        ')', ']', '}'
    ])

    newline: [
        /^\n[^\S\n]*/
    ],

    bool: regexmap([
        'true'
        'false'
    ]),

    keyword: regexmap([
        '_', 'pass', 'equals',
        'null', 'undefined', 'not', 'true', 'false', 'arguments',
        'export', 'import', 'void', 'debugger', 'with',
        'delete', 'var', 'let', 'const', 'typeof',
        'new', 'class', 'extends', 'this', 'self', 'super',
        'return', 'yield', 'function',
        'if', 'else', 'else if',
        'switch', 'case', 'default',
        'do', 'while', 'break', 'continue',
        'for', 'in', 'of', 'instanceof',
        'try', 'catch', 'finally', 'throw',
        'enum', 'implements', 'static', 'public', 'package',
        'interface', 'protected', 'private', 'abstract', 'final',
        'native', 'boolean', 'float', 'short', 'byte',
        'goto', 'synchronized', 'char', 'int', 'transient', 'double',
        'long', 'volatile'
    ]),

    identifier: [
        /^[a-zA-Z_$][0-9a-zA-Z_$]*/
    ],

    number: [
        /^[0-9]+/,
        /^[0-9]*\.[0-9]+/,
        /^0x[0-9a-fA-F]+/
    ],

    string: [
        /^"("|.*?[^\\]"|.*?\\\\")/,
        /^'('|.*?[^\\]'|.*?\\\\')/
    ],

    regex: [
        /^\/[^\/*](.*?[^\\]\/|.*?\\\\\/)[gim]*/
    ],

    comment: [
        /^\/\/.*/,
        /^\/\*[^]*?\*\//
    ],

    ignore: [
        /^[^\S\n]+/,
        /^#[A-Z]+/
    ]
}

module.exports = function(input):
    [residue, offset] = [input, 0]
    tokens = []

    // Tokenizer
    while residue.length > 0:
        lastType = null
        [type, value] = [null, '']
        if tokens.length > 0: [..., [lastType, _]] = tokens

        for t, list in rules:
            // Check whether regex or division
            if t == 'regex' && lastType not in ['operator', 'leftdelimiter', 'delimiter', 'newline', null]:
                continue

            for regex in list:
                matches = regex.exec(residue)
                if matches == null || matches[0].length <= value.length:
                    continue

                [type, value] = [t, matches[0]]

        // No token found
        if type == null: throw {
            message: "Syntax error: Unexpected '" + residue[0] + "'",
            offset: offset
        }

        // Don't add newline twice
        if type == 'newline' && tokens.length > 0 && tokens[tokens.length - 1][0] == 'newline':
            tokens.pop()

        if type != 'ignore':
            token = [type, value.trim()]
            if token[1] == '': token[1] = value
            token.offset = offset
            tokens.push(token)

        offset += value.length
        residue = residue[value.length...]

    output = []

    // Detect indents & dedents
    indents = [x.length - 1 for [t, x] in tokens if t == 'newline']
    indentLength = gcd(*indents.filter(x => x != 0))
    [lastDepth, useTabs] = [0, null]

    for i, [type, value] in tokens:
        if type != 'newline':
            output.push(tokens[i])
            continue

        depth = (value.length - 1) / indentLength

        if depth != 0:
            // Check for mixed indentation
            if useTabs == null:
                useTabs = '\t' in value
            else if useTabs != ('\t' in value):
                throw {
                    message: 'Mixed indentation',
                    offset: tokens[i].offset
                }

        if depth > lastDepth:
            for _ in [1, ..., depth - lastDepth]:
                token = ['newline', 'indent']
                token.offset = tokens[i].offset
                output.push(token)
        else if depth < lastDepth:
            for _ in [1, ..., lastDepth - depth]:
                token = ['newline', 'dedent']
                token.offset = tokens[i].offset
                output.push(token)
        else:
            output.push(['newline', 'nodent'])

        lastDepth = depth

    for i in [1,2...lastDepth]:
        output.push(['newline', 'dedent'])

    // Remove superfluous newlines
    list = [
        ['newline', 'indent'],
        ['operator', '*'],
        ['operator', '/'],
        ['operator', '^'],
        ['operator', '%'],
        ['operator', '-'],
        ['operator', '+'],
        ['operator', '='],
        ['operator', '+='],
        ['operator', '^='],
        ['operator', '*='],
        ['operator', '%='],
        ['operator', '-='],
        ['operator', '+='],
        ['operator', '=>'],
        ['operator', '??'],
        ['operator', '?'],
        ['operator', '||'],
        ['operator', '&&'],
        ['operator', '<'],
        ['operator', '>'],
        ['operator', '<='],
        ['operator', '>='],
        ['operator', '=='],
        ['operator', '!='],
        ['operator', 'in'],
        ['operator', 'not in'],
        ['operator', 'instanceof'],
        ['operator', 'typeof'],
        ['operator', 'new'],
        ['operator', 'equals'],
        ['operator', 'not equals'],
        ['operator', '.']
        ['operator', '?.'],
        ['delimiter', '...'],
        ['delimiter', ','],
    ]

    for i, token in output:
        if !list.some(x => token equals x): continue

        if output[i - 1]?[0] == 'newline':
            removeNewline(output, i - 1)
        if token[0] != 'newline' && output[i + 1]?[0] == 'newline':
            removeNewline(output, i + 1)

    return output.filter(x => x != null)
