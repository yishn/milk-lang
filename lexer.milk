escaperegex = x => x.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
regexmap = l => l.map(x => new RegExp('^' + escaperegex(x)))

function gcd(*args):
    if args.length <= 1: return args[0] ?? 1

    gcdInner = (a, b) => b == 0 ? a : gcdInner(b, a % b)

    middle = Math.floor((args.length - 1) / 2)
    return gcdInner(gcd(*args[0...middle]), gcd(*args[middle + 1...]))

function removeIndent(tokens, i):
    depth = 0
    for k, [type, value, _] in tokens if k >= i:
        if type == 'newline':
            if value == 'indent': depth++
            else if value == 'dedent': depth--

        if depth == 0:
            tokens[k] = null

rules = {
    operator: regexmap([
        '*', '/', '^', '%', '-', '+',
        '=', '--', '++', '+=', '^=', '*=', '%=', '-=', '+=',
        '=>', '??', '?',
        '||', '&&', '!',
        '<', '>', '<=', '>=', '==', '!=',
        'in', 'not in', 'instanceof', 'typeof', 'new',
        'equals', 'not equals'
    ])

    delimiter: regexmap([
        ';', ',', '.', '?.', '(', '?(', ')',
        '[', '?[', ']', '{', '}', ':', '...'
    ])

    newline: [
        /^\n[^\S\n]*/
    ]

    bool: regexmap([
        'true'
        'false'
    ])

    keyword: regexmap([
        '_', 'pass', 'equals',
        'null', 'undefined', 'not', 'true', 'false', 'arguments',
        'export', 'import', 'void', 'debugger', 'with',
        'delete', 'var', 'let', 'const', 'typeof',
        'new', 'class', 'extends', 'this', 'self', 'super',
        'return', 'yield', 'function',
        'if', 'else', 'else if',
        'switch', 'case', 'default',
        'do', 'while', 'break', 'continue',
        'for', 'in', 'of', 'instanceof',
        'try', 'catch', 'finally', 'throw',
        'enum', 'implements', 'static', 'public', 'package',
        'interface', 'protected', 'private', 'abstract', 'final',
        'native', 'boolean', 'float', 'short', 'byte',
        'goto', 'synchronized', 'char', 'int', 'transient', 'double',
        'long', 'volatile'
    ])

    identifier: [
        /^[a-zA-Z_$][0-9a-zA-Z_$]*/
    ]

    number: [
        /^[0-9]+/
        /^[0-9]*\.[0-9]+/
        /^0x[0-9a-fA-F]+/
    ]

    string: [
        /^"("|.*?[^\\]"|.*?\\\\")/
        /^'('|.*?[^\\]'|.*?\\\\')/
    ]

    regex: [
        /^\/[^\/*](.*?[^\\]\/|.*?\\\\\/)[gim]*/
    ]

    comment: [
        /^\/\/.*/
        /^\/\*[^]*?\*\//
    ]

    ignore: [
        /^[^\S\n]+/
        /^#[A-Z]+/
    ]
}

module.exports = function(input):
    [residue, offset] = [input, 0]
    tokens = []

    // Tokenizer
    while residue.length > 0:
        lastType = null
        [type, value] = [null, '']
        if tokens.length > 0: [..., [lastType, _, _]] = tokens

        for t, list in rules:
            // Check whether regex or division
            if t == 'regex' && lastType not in ['operator', 'delimiter', 'newline', null]:
                continue

            for regex in list:
                matches = regex.exec(residue)
                if matches == null || matches[0].length <= value.length:
                    continue

                [type, value] = [t, matches[0]]

        // No token found
        if type == null: throw {
            message: "Syntax error: Unexpected '" + residue[0] + "'"
            offset: offset
        }

        // Don't add newline twice
        if type == 'newline' && tokens.length > 0 && tokens[tokens.length - 1][0] == 'newline':
            tokens.pop()

        if type != 'ignore':
            tokens.push([type, value, offset])

        offset += value.length
        residue = residue[value.length...]

    output = []

    // Detect indents & dedents
    indents = [x.length - 1 for [t, x, _] in tokens if t == 'newline']
    indentLength = gcd(*indents.filter(x => x != 0))
    [lastDepth, useTabs] = [0, null]

    for i, [type, value, offset] in tokens:
        if type != 'newline':
            output.push(tokens[i])
            continue

        depth = (value.length - 1) / indentLength

        if depth != 0:
            // Check for mixed indentation
            if useTabs == null:
                useTabs = '\t' in value
            else if useTabs != ('\t' in value):
                throw {
                    message: 'Mixed indentation',
                    offset: offset
                }

        if depth > lastDepth:
            for _ in [1, ..., depth - lastDepth]:
                output.push(['newline', 'indent', offset])
        else if depth < lastDepth:
            for _ in [1, ..., lastDepth - depth]:
                output.push(['newline', 'dedent', offset])
        else:
            output.push(tokens[i])

        lastDepth = depth

    // Remove superfluous indents
    for i, [*token, _] in output if i >= 1:
        if token not equals ['newline', 'indent']: continue
        if output[i - 1][0...1] equals ['newline', 'indent']:
            removeIndent(output, i)

    return output.filter(x => x != null)
